# 多跳推理实现逻辑详解

## 目录
1. [什么是多跳推理](#什么是多跳推理)
2. [多跳推理在GraphRAG中的应用](#多跳推理在GraphRAG中的应用)
3. [核心算法实现](#核心算法实现)
4. [存储层实现对比](#存储层实现对比)
5. [查询中的多跳推理](#查询中的多跳推理)
6. [前端可视化方案](#前端可视化方案)

---

## 什么是多跳推理

### 概念定义

多跳推理（Multi-hop Reasoning）是指在知识图谱中通过多个关系步骤连接不同实体，从而发现间接关联的推理过程。

```
单跳（1-hop）:          多跳（2-hop）:              多跳（3-hop）:
A ──→ B                 A ──→ B ──→ C             A ──→ B ──→ C ──→ D
直接关联               间接关联                  长距离关联
```

### 实际场景示例

**场景1：公司股权关系**
```
用户查询："阿里巴巴投资了哪些公司的子公司？"

多跳推理路径：
阿里巴巴 ──invest──→ 公司A ──parent_of──→ 公司A1
        ──invest──→ 公司B ──parent_of──→ 公司B1
        ──invest──→ 公司C ──partner──→  公司C2 ──parent_of──→ 公司C2_sub

从阿里巴巴到C2_sub是3跳关系
```

**场景2：学术论文引用**
```
用户查询："这篇论文引用了哪些相关领域的基础研究？"

多跳推理路径：
论文A ──cites──→ 论文B ──cites──→ 论文C（基础研究）
     ──cites──→ 论文D ──related──→ 论文E ──cites──→ 论文F（基础研究）
```

---

## 多跳推理在GraphRAG中的应用

### 1. 知识图谱可视化中的多跳

当用户在可视化界面查看某个实体时，系统会自动展开多跳邻居：

```python
# API调用示例
GET /graphs?label=Apple&max_depth=3&max_nodes=1000

参数说明：
- label: 起始节点（Apple）
- max_depth: 最大跳数（3跳）
- max_nodes: 最大返回节点数（1000）
```

**返回结果：**
- 0跳：Apple 实体本身
- 1跳：直接关联的实体（CEO、产品、竞争对手）
- 2跳：间接关联的实体（竞争对手的CEO、产品组件供应商）
- 3跳：长距离关联（供应商的母公司、合作伙伴）

### 2. 查询检索中的多跳

在 `local` 和 `hybrid` 查询模式下，系统会自动执行多跳推理：

```python
# 检索流程
Query: "Apple的芯片供应商有哪些？"

Step 1: 识别实体
- 提取关键词: ["Apple", "芯片", "供应商"]

Step 2: 实体匹配（1跳）
- 在知识图谱中找到 "Apple" 实体
- 获取直接邻居: ["iPhone", "Tim Cook", "A系列芯片", "TSMC"]

Step 3: 关系过滤（2跳）
- 从 "Apple" 出发，找 "supplier" 关系
- 发现 "Apple" ──supplier──→ "TSMC"
- 发现 "Apple" ──designs──→ "A系列芯片"

Step 4: 扩展搜索（3跳）
- 从 "A系列芯片" 找制造厂商
- 发现 "A系列芯片" ──manufactured_by──→ "TSMC"
- 发现 "TSMC" ──supplier_of──→ ["Nvidia", "AMD"]

最终答案整合所有跳数的信息
```

---

## 核心算法实现

### 1. 广度优先搜索（BFS）算法

GraphRAG使用BFS作为多跳推理的核心算法：

```python
# NetworkX实现（网络图存储）
async def get_knowledge_graph(
    self,
    node_label: str,           # 起始节点
    max_depth: int = 3,         # 最大跳数
    max_nodes: int = 1000,      # 最大节点数
) -> KnowledgeGraph:
    """
    使用改进的BFS算法获取多跳子图
    特点：
    1. 按跳数层级遍历
    2. 每层按节点度数（重要性）排序
    3. 支持双向边遍历
    """
    
    graph = await self._get_graph()
    result = KnowledgeGraph()
    
    # BFS队列：存储 (节点, 深度, 度数)
    queue = [(node_label, 0, graph.degree(node_label))]
    visited = set()
    bfs_nodes = []
    
    while queue and len(bfs_nodes) < max_nodes:
        # 获取当前深度的所有节点
        current_depth = queue[0][1]
        current_level_nodes = []
        
        # 提取当前层的所有节点
        while queue and queue[0][1] == current_depth:
            current_level_nodes.append(queue.pop(0))
        
        # 按度数排序（优先处理重要节点）
        current_level_nodes.sort(key=lambda x: x[2], reverse=True)
        
        # 处理当前层节点
        for current_node, depth, degree in current_level_nodes:
            if current_node not in visited:
                visited.add(current_node)
                bfs_nodes.append(current_node)
                
                # 如果未达最大深度，扩展邻居
                if depth < max_depth:
                    neighbors = list(graph.neighbors(current_node))
                    unvisited_neighbors = [n for n in neighbors if n not in visited]
                    
                    # 将邻居加入队列（深度+1）
                    for neighbor in unvisited_neighbors:
                        neighbor_degree = graph.degree(neighbor)
                        queue.append((neighbor, depth + 1, neighbor_degree))
    
    # 返回子图
    subgraph = graph.subgraph(bfs_nodes)
    return self._convert_to_knowledge_graph(subgraph)
```

### 2. PostgreSQL + AGE实现

使用Cypher查询语言实现高效的BFS：

```python
async def _bfs_subgraph(
    self,
    node_label: str,
    max_depth: int,
    max_nodes: int
) -> KnowledgeGraph:
    """
    在PostgreSQL中使用Apache AGE扩展实现BFS
    """
    from collections import deque
    
    result = KnowledgeGraph()
    visited_nodes = set()
    queue = deque()
    
    # 1. 获取起始节点
    start_node = await self._get_start_node(node_label)
    queue.append((start_node, 0))
    visited_nodes.add(node_label)
    result.nodes.append(start_node)
    
    # 2. BFS主循环
    while queue and len(result.nodes) < max_nodes:
        # 获取当前深度的所有节点
        current_depth = queue[0][1]
        current_level_nodes = []
        
        while queue and queue[0][1] == current_depth:
            node, depth = queue.popleft()
            if depth > max_depth:
                continue
            current_level_nodes.append(node)
        
        if current_depth > max_depth:
            continue
            
        # 批量查询出边和入边（性能优化）
        node_ids = [node.labels[0] for node in current_level_nodes]
        
        # 出边查询：MATCH (n)-[r]->(neighbor)
        outgoing_query = f"""
            UNWIND [{formatted_ids}] AS node_id
            MATCH (n:base {{entity_id: node_id}})
            OPTIONAL MATCH (n)-[r]->(neighbor:base)
            RETURN n, r, neighbor, true AS is_outgoing
        """
        
        # 入边查询：MATCH (n)<-[r]-(neighbor)
        incoming_query = f"""
            UNWIND [{formatted_ids}] AS node_id
            MATCH (n:base {{entity_id: node_id}})
            OPTIONAL MATCH (n)<-[r]-(neighbor:base)
            RETURN n, r, neighbor, false AS is_outgoing
        """
        
        # 执行查询
        outgoing_results = await self._query(outgoing_query)
        incoming_results = await self._query(incoming_query)
        
        # 处理结果，构建知识图谱
        for record in outgoing_results + incoming_results:
            if record.get("neighbor") and record.get("r"):
                neighbor_entity = record["neighbor"]
                relation = record["r"]
                
                # 添加邻居节点到结果
                if neighbor_entity not in visited_nodes:
                    visited_nodes.add(neighbor_entity)
                    neighbor_node = self._create_node(neighbor_entity)
                    result.nodes.append(neighbor_node)
                    
                    # 将邻居加入队列（深度+1）
                    if current_depth < max_depth:
                        queue.append((neighbor_node, current_depth + 1))
                
                # 添加边到结果
                edge = self._create_edge(record)
                result.edges.append(edge)
    
    return result
```

### 3. MongoDB实现

使用`$graphLookup`聚合管道实现多跳：

```python
async def get_knowledge_subgraph_in_out_bound_bfs(
    self,
    node_label: str,
    max_depth: int,
    max_nodes: int
) -> KnowledgeGraph:
    """
    使用MongoDB的$graphLookup实现多跳查询
    """
    result = KnowledgeGraph()
    seen_nodes = {node_label}
    
    # MongoDB的$graphLookup聚合管道
    pipeline = [
        # 1. 匹配起始节点
        {"$match": {"_id": node_label}},
        
        # 2. 正向遍历（出边）
        {
            "$graphLookup": {
                "from": self._edge_collection_name,
                "startWith": "$_id",
                "connectFromField": "target_node_id",  # 从目标节点继续
                "connectToField": "source_node_id",     # 连接到源节点
                "maxDepth": max_depth - 1,
                "depthField": "depth",                   # 记录跳数
                "as": "connected_edges"
            }
        },
        
        # 3. 反向遍历（入边）
        {
            "$unionWith": {
                "coll": self._collection_name,
                "pipeline": [
                    {"$match": {"_id": node_label}},
                    {
                        "$graphLookup": {
                            "from": self._edge_collection_name,
                            "startWith": "$_id",
                            "connectFromField": "source_node_id",  # 从源节点继续
                            "connectToField": "target_node_id",     # 连接到目标节点
                            "maxDepth": max_depth - 1,
                            "depthField": "depth",
                            "as": "connected_edges"
                        }
                    }
                ]
            }
        }
    ]
    
    # 执行聚合查询
    cursor = await self.collection.aggregate(pipeline, allowDiskUse=True)
    
    # 处理结果（按深度排序）
    node_edges = []
    async for doc in cursor:
        if doc.get("connected_edges"):
            node_edges.extend(doc["connected_edges"])
    
    # 按深度升序、权重降序排序
    node_edges.sort(key=lambda x: (x["depth"], -x["weight"]))
    
    # 收集节点（限制max_nodes）
    for edge in node_edges:
        if len(seen_nodes) >= max_nodes:
            break
            
        # 添加源节点和目标节点
        for node_id in [edge["source_node_id"], edge["target_node_id"]]:
            if node_id not in seen_nodes:
                seen_nodes.add(node_id)
                node_doc = await self.collection.find_one({"_id": node_id})
                if node_doc:
                    result.nodes.append(self._construct_graph_node(node_id, node_doc))
        
        # 添加边
        edge_id = f"{edge['source_node_id']}-{edge['target_node_id']}"
        result.edges.append(self._construct_graph_edge(edge_id, edge))
    
    return result
```

### 4. Neo4j实现

使用Cypher的`apoc.path.subgraphAll`实现高效多跳：

```python
async def get_knowledge_graph(
    self,
    node_label: str,
    max_depth: int = 3,
    max_nodes: int = 1000,
) -> KnowledgeGraph:
    """
    使用Neo4j的APOC扩展实现多跳子图查询
    """
    result = KnowledgeGraph()
    
    # 使用APOC的subgraphAll函数
    query = f"""
        MATCH (start:base {{entity_id: $node_label}})
        CALL apoc.path.subgraphAll(start, {{
            maxLevel: $max_depth,      // 最大深度（跳数）
            limit: $max_nodes,         // 最大节点数
            bfs: true                  // 使用BFS
        }})
        YIELD nodes, relationships
        RETURN nodes, relationships
    """
    
    records = await self._query(query, {
        "node_label": node_label,
        "max_depth": max_depth,
        "max_nodes": max_nodes
    })
    
    if records:
        record = records[0]
        # 处理节点
        for node in record["nodes"]:
            result.nodes.append(KnowledgeGraphNode(
                id=str(node.id),
                labels=list(node.labels),
                properties=dict(node)
            ))
        
        # 处理关系
        for rel in record["relationships"]:
            result.edges.append(KnowledgeGraphEdge(
                id=str(rel.id),
                source=str(rel.start_node.id),
                target=str(rel.end_node.id),
                type=rel.type,
                properties=dict(rel)
            ))
    
    return result
```

---

## 存储层实现对比

| 存储后端 | 实现方式 | 性能 | 适用场景 |
|---------|---------|------|---------|
| **NetworkX** | Python BFS + 内存图 | 快（内存操作） | 小型图谱、开发和测试 |
| **PostgreSQL + AGE** | Cypher BFS查询 | 中等 | 企业级应用，需要复杂查询 |
| **Neo4j** | APOC subgraphAll | 快（原生图数据库） | 大型图谱、生产环境 |
| **MongoDB** | $graphLookup | 中等 | 文档+图混合场景 |
| **Memgraph** | Cypher查询 | 快 | 高性能实时查询 |

---

## 查询中的多跳推理

### 1. Local模式的多跳实现

```python
# lightrag/operate.py

async def _get_node_data(
    query: str,
    knowledge_graph_inst: BaseGraphStorage,
    entities_vdb: BaseVectorStorage,
    query_param: QueryParam,
):
    """
    Local模式：基于实体的多跳检索
    """
    # 1. 向量搜索找到相似实体（起始节点）
    results = await entities_vdb.query(query, top_k=query_param.top_k)
    node_ids = [r["entity_name"] for r in results]
    
    # 2. 批量获取实体详细信息
    nodes_dict = await knowledge_graph_inst.get_nodes_batch(node_ids)
    degrees_dict = await knowledge_graph_inst.node_degrees_batch(node_ids)
    
    # 3. 多跳扩展：查找相关边（1跳）
    use_relations = await _find_most_related_edges_from_entities(
        node_datas, query_param, knowledge_graph_inst
    )
    
    # _find_most_related_edges_from_entities内部实现：
    # - 获取实体的所有出边和入边
    # - 按权重和度数排序
    # - 返回Top-K关系
    
    return node_datas, use_relations
```

### 2. 关系发现的多跳

```python
async def _find_most_related_edges_from_entities(
    node_datas: list[dict],
    query_param: QueryParam,
    knowledge_graph_inst: BaseGraphStorage,
):
    """
    从实体出发，发现多跳关系
    """
    node_names = [dp["entity_name"] for dp in node_datas]
    
    # 批量获取边的信息（1跳）
    batch_edges_dict = await knowledge_graph_inst.get_nodes_edges_batch(node_names)
    
    all_edges = []
    seen = set()
    
    for node_name in node_names:
        # 获取该节点的所有边
        this_edges = batch_edges_dict.get(node_name, [])
        
        for edge in this_edges:
            # 边的去重（无向图）
            sorted_edge = tuple(sorted(edge))
            if sorted_edge not in seen:
                seen.add(sorted_edge)
                all_edges.append(sorted_edge)
    
    # 批量获取边的属性和度数
    edge_data_dict, edge_degrees_dict = await asyncio.gather(
        knowledge_graph_inst.get_edges_batch(edge_pairs),
        knowledge_graph_inst.edge_degrees_batch(edge_pairs),
    )
    
    # 按度数和权重排序（优先级）
    all_edges_data = sorted(
        all_edges_data, 
        key=lambda x: (x["rank"], x["weight"]), 
        reverse=True
    )
    
    return all_edges_data[:query_param.top_k]  # 返回Top-K关系
```

### 3. 文本块的多跳收集

```python
async def _find_related_text_unit_from_entities(
    node_datas: list[dict],
    query_param: QueryParam,
    text_chunks_db: BaseKVStorage,
    knowledge_graph_inst: BaseGraphStorage,
    query: str = None,
    chunks_vdb: BaseVectorStorage = None,
    chunk_tracking: dict = None,
):
    """
    从实体出发，多跳收集相关文本块
    """
    # Step 1: 收集所有实体的source_id（文本块引用）
    entities_with_chunks = []
    for entity in node_datas:
        if entity.get("source_id"):
            # source_id可能包含多个文本块ID，用分隔符分割
            chunks = split_string_by_multi_markers(
                entity["source_id"], [GRAPH_FIELD_SEP]
            )
            if chunks:
                entities_with_chunks.append({
                    "entity_name": entity["entity_name"],
                    "chunks": chunks,
                    "entity_data": entity,
                })
    
    # Step 2: 统计文本块出现频率（多跳汇聚）
    chunk_occurrence_count = {}
    for entity_info in entities_with_chunks:
        for chunk_id in entity_info["chunks"]:
            chunk_occurrence_count[chunk_id] = chunk_occurrence_count.get(chunk_id, 0) + 1
    
    # Step 3: 选择策略
    kg_chunk_pick_method = text_chunks_db.global_config.get(
        "kg_chunk_pick_method", DEFAULT_KG_CHUNK_PICK_METHOD
    )
    
    if kg_chunk_pick_method == "WEIGHT":
        # 加权随机选择（高频文本块优先）
        selected_chunks = pick_by_weighted_polling(
            chunk_occurrence_count, max_related_chunks
        )
    else:  # VECTOR
        # 向量相似度选择
        selected_chunks = pick_by_vector_similarity(
            chunks_vdb, query, chunk_occurrence_count.keys(), max_related_chunks
        )
    
    return selected_chunks
```

---

## 前端可视化方案

### 1. 多跳层级可视化

```typescript
// 展示不同跳数的节点
interface HopLevel {
  level: number;        // 跳数：0, 1, 2, 3...
  nodes: GraphNode[];   // 该层的节点
  edges: GraphEdge[];   // 连接到下一层的边
}

function HopLevelVisualization({ hopLevels }: { hopLevels: HopLevel[] }) {
  return (
    <div className="hop-levels">
      {hopLevels.map((level, idx) => (
        <div key={level.level} className="hop-level">
          <div className="level-header">
            <span className="level-badge">{level.level}跳</span>
            <span className="node-count">{level.nodes.length}个节点</span>
          </div>
          
          <div className="level-nodes">
            {level.nodes.map(node => (
              <NodeCard 
                key={node.id} 
                node={node}
                highlighted={level.level === 0}  // 起始节点高亮
              />
            ))}
          </div>
          
          {idx < hopLevels.length - 1 && (
            <div className="level-connections">
              <ArrowDown />
              <span>{level.edges.length}个关系</span>
            </div>
          )}
        </div>
      ))}
    </div>
  );
}
```

### 2. 多跳路径高亮

```typescript
// 当用户悬停在某个节点时，高亮显示从起始节点到该节点的路径
function highlightMultiHopPath(
  graph: GraphData,
  startNodeId: string,
  targetNodeId: string
): PathInfo {
  // 使用BFS找到最短路径
  const queue = [[startNodeId]];
  const visited = new Set([startNodeId]);
  
  while (queue.length > 0) {
    const path = queue.shift()!;
    const currentNode = path[path.length - 1];
    
    if (currentNode === targetNodeId) {
      return {
        nodes: path,
        edges: extractEdgesFromPath(path, graph.edges),
        hopCount: path.length - 1
      };
    }
    
    // 找到当前节点的所有邻居
    const neighbors = findNeighbors(currentNode, graph.edges);
    for (const neighbor of neighbors) {
      if (!visited.has(neighbor)) {
        visited.add(neighbor);
        queue.push([...path, neighbor]);
      }
    }
  }
  
  return null;  // 未找到路径
}
```

### 3. 交互式多跳探索

```typescript
// 用户可以点击"展开"来查看下一跳的节点
function ExpandableNode({ node, currentDepth, maxDepth }: NodeProps) {
  const [expanded, setExpanded] = useState(false);
  const [childNodes, setChildNodes] = useState<GraphNode[]>([]);
  
  const handleExpand = async () => {
    if (!expanded && currentDepth < maxDepth) {
      // 加载下一跳节点
      const nextHop = await fetchSubgraph(node.id, 1);
      setChildNodes(nextHop.nodes);
    }
    setExpanded(!expanded);
  };
  
  return (
    <div className="expandable-node">
      <NodeCard node={node} />
      
      {currentDepth < maxDepth && (
        <button 
          className="expand-btn"
          onClick={handleExpand}
        >
          {expanded ? '收起' : '展开'}
          {expanded ? <ChevronUp /> : <ChevronDown />}
        </button>
      )}
      
      {expanded && childNodes.length > 0 && (
        <div className="child-nodes">
          {childNodes.map(child => (
            <ExpandableNode
              key={child.id}
              node={child}
              currentDepth={currentDepth + 1}
              maxDepth={maxDepth}
            />
          ))}
        </div>
      )}
    </div>
  );
}
```

### 4. 多跳统计面板

```typescript
// 显示多跳检索的统计信息
function MultiHopStats({ graph }: { graph: GraphData }) {
  const stats = useMemo(() => {
    // 计算每个跳数的节点数量
    const hopCounts = new Map<number, number>();
    
    // BFS遍历计算跳数
    const visited = new Set<string>();
    const queue: [string, number][] = [[graph.nodes[0].id, 0]];
    
    while (queue.length > 0) {
      const [nodeId, hop] = queue.shift()!;
      
      if (visited.has(nodeId)) continue;
      visited.add(nodeId);
      
      hopCounts.set(hop, (hopCounts.get(hop) || 0) + 1);
      
      // 找到邻居
      const neighbors = findNeighbors(nodeId, graph.edges);
      for (const neighbor of neighbors) {
        if (!visited.has(neighbor)) {
          queue.push([neighbor, hop + 1]);
        }
      }
    }
    
    return Array.from(hopCounts.entries())
      .sort((a, b) => a[0] - b[0])
      .map(([hop, count]) => ({ hop, count }));
  }, [graph]);
  
  return (
    <div className="multi-hop-stats">
      <h4>多跳分布</h4>
      <div className="hop-bars">
        {stats.map(({ hop, count }) => (
          <div key={hop} className="hop-bar">
            <div className="bar-label">{hop}跳</div>
            <div 
              className="bar-fill"
              style={{ width: `${(count / stats[0].count) * 100}%` }}
            />
            <div className="bar-count">{count}</div>
          </div>
        ))}
      </div>
    </div>
  );
}
```

---

## 总结

### 多跳推理的核心机制

1. **BFS算法**：保证按跳数层级遍历，不遗漏任何路径
2. **批量查询**：减少数据库往返次数，提高性能
3. **度数排序**：优先处理重要节点（度数高的节点）
4. **双向遍历**：同时考虑入边和出边，完整图谱结构

### 性能优化要点

1. **限制跳数**：通常max_depth=3即可满足大部分需求
2. **限制节点数**：防止图谱过大导致性能问题
3. **异步并行**：使用asyncio批量处理查询
4. **缓存机制**：缓存频繁访问的子图

### 应用场景

- **知识探索**：发现实体间的隐藏关联
- **问答系统**：回答需要多跳推理的复杂问题
- **推荐系统**：基于多跳关系推荐相关内容
- **欺诈检测**：发现复杂的关联网络

---

**文档版本**: v1.0  
**更新日期**: 2026-02-07
