# 证据链算法说明

## 一、核心函数概览

三个证据推理函数均位于 `kg/neo4j_impl.py`，从第2229行开始：

| 函数 | 行号 | 核心功能 |
|------|------|----------|
| `get_causal_chain()` | 2229 | 因果链追溯 |
| `aggregate_evidence()` | 2300 | 证据聚合 |
| `cross_validate()` | 2381 | 交叉验证 |

---

## 二、因、果链追溯 `get_causal_chain()` 源码解析

### 2.1 函数签名与参数

```python
async def get_causal_chain(
    self,
    entity_id: str,           # 起始实体ID
    max_depth: int = 5,        # 最大追溯深度
    evidence_level: str = None, # 证据等级过滤
    limit: int = 20,           # 返回结果限制
) -> list[dict]
```

### 2.2 核心Cypher查询逻辑

```cypher
MATCH path = (start:`{workspace}` {entity_id: $entity_id})
   -[r:DIRECTED*1..{max_depth}]->(end:`{workspace}`)
WHERE all(rel IN relationships(path) WHERE rel.relation_type = "causal")
```

**关键点解析**：

| 语法 | 含义 |
|------|------|
| `[r:DIRECTED*1..max_depth]` | 变长路径匹配，1到max_depth跳 |
| `relation_type = "causal"` | 只匹配因果类型的边 |
| `all(r IN ... WHERE ...)` | 路径上所有边都必须满足条件 |

### 2.3 权重计算算法

```cypher
reduce(weight_sum = 0, rel IN relationships(path) | weight_sum + 
    CASE rel.evidence_level
        WHEN "S" THEN 4
        WHEN "A" THEN 3
        WHEN "B" THEN 2
        WHEN "C" THEN 1
        ELSE 0
    END) as chain_weight
```

**算法说明**：

- 使用 `reduce()` 聚合函数遍历路径上的每条边
- 将每条边的证据等级转换为权重后累加

**返回结构**：

- `chain_entities`: 路径上的实体列表
- `chain_relations`: 路径上的关系列表
- `chain_length`: 路径长度（跳数）
- `chain_weight`: 综合权重

### 2.4 执行流程图

```
输入: entity_id="降准政策"
         │
         ▼
    ┌─────────────────────────────────────┐
    │ 1. 构建动态Cypher查询               │
    │   - 拼接max_depth                   │
    │   - 拼接evidence_level条件          │
    └─────────────────────────────────────┘
         │
         ▼
    ┌─────────────────────────────────────┐
    │ 2. 执行路径搜索                      │
    │   MATCH path = (start)-[r*1..5]->   │
    │   WHERE all(r.relation_type="causal")│
    └─────────────────────────────────────┘
         │
         ▼
    ┌─────────────────────────────────────┐
    │ 3. 计算权重 & 排序                   │
    │   ORDER BY chain_length DESC,        │
    │            chain_weight DESC         │
    └─────────────────────────────────────┘
         │
         ▼
    输出: [
      {start_entity, end_entity, 
       chain_entities=[...], 
       chain_relations=[...], 
       chain_length=3, chain_weight=12}
    ]
```

---

## 三、证据聚合 `aggregate_evidence()` 源码解析

### 3.1 函数签名与参数

```python
async def aggregate_evidence(
    self,
    topic: str = None,           # 主题关键词
    scene_tag: str = None,        # 场景标签
    evidence_level: str = None,  # 证据等级
    min_weight: float = 0,        # 最小权重阈值
    limit: int = 50,             # 返回限制
) -> list[dict]
```

### 3.2 动态条件构建

```python
conditions = []
params = {}

if topic:
    conditions.append("(n.entity_name CONTAINS $topic OR n.description CONTAINS $topic)")
    params["topic"] = topic

if scene_tag:
    conditions.append("ANY(tag IN n.scene_tags WHERE tag = $scene_tag)")
    params["scene_tag"] = scene_tag

if evidence_level:
    conditions.append("n.evidence_level = $evidence_level")
    params["evidence_level"] = evidence_level.upper()

where_clause = " AND ".join(conditions) if conditions else "1=1"
```

**条件组合逻辑**：

- 多条件之间是 **AND** 关系
- `CONTAINS` 实现模糊匹配
- `ANY(tag IN ...)` 检查数组中是否存在目标标签

### 3.3 聚合查询核心逻辑

```cypher
MATCH (n:`{workspace}`)
WHERE {conditions}
OPTIONAL MATCH (n)-[r]->(other:`{workspace}`)
WITH n.entity_name as entity,
     n.evidence_level as level,
     collect(DISTINCT n.scene_tags) as tags,
     collect(DISTINCT {target, relation, level, weight}) as relations,
     sum(weight) as total_weight,
     count(r) as relation_count
WHERE total_weight >= $min_weight
RETURN entity, entity_type, level, tags, relations, total_weight, relation_count
ORDER BY total_weight DESC
```

**关键聚合操作**：

| 操作 | 作用 |
|------|------|
| `collect(DISTINCT ...)` | 收集相关数据，去重 |
| `sum(weight)` | 按实体聚合权重 |
| `count(r)` | 统计关联数量 |
| `WHERE total_weight >= min_weight` | 过滤低权重结果 |

### 3.4 执行流程图

```
输入: topic="科创板", scene_tag="投研分析"
         │
         ▼
    ┌─────────────────────────────────────┐
    │ 1. 构建动态WHERE条件                 │
    │   entity_name CONTAINS "科创板"     │
    │   AND ANY(scene_tags = "投研分析")  │
    └─────────────────────────────────────┘
         │
         ▼
    ┌─────────────────────────────────────┐
    │ 2. 查询实体 & 关联关系               │
    │   MATCH (n)-[r]->(other)            │
    └─────────────────────────────────────┘
         │
         ▼
    ┌─────────────────────────────────────┐
    │ 3. 按实体聚合                        │
    │   - 合并scene_tags                  │
    │   - 累加weight                      │
    │   - 收集relations                   │
    └─────────────────────────────────────┘
         │
         ▼
    输出: [
      {entity: "科创板", level: "S", 
       tags: [["投研分析", "风险控制"]], 
       relations: [...], total_weight: 15, 
       relation_count: 5}
    ]
```

---

## 四、交叉验证 `cross_validate()` 源码解析

### 4.1 函数签名与参数

```python
async def cross_validate(
    self,
    claim_entity: str,              # 待验证的观点实体
    min_evidence_count: int = 1,   # 最少证据数量
) -> dict
```

### 4.2 双分支查询模式

```cypher
MATCH (claim:`{workspace}` {entity_name: $claim})
OPTIONAL MATCH (claim)-[r1:DIRECTED]->(supporting:`{workspace}`)
WHERE r1.relation_type = "support"
OPTIONAL MATCH (claim)-[r2:DIRECTED]->(contradicting:`{workspace}`)
WHERE r2.relation_type = "contradict"
```

**设计亮点**：

- 使用 **双OPTIONAL MATCH** 同时查找支持和反驳证据
- 支持证据：`relation_type = "support"`
- 反驳证据：`relation_type = "contradict"`

### 4.3 权重计算与结论判定

```cypher
-- 支持证据权重
reduce(s_weight = 0, e IN support_evidence | s_weight + 
    CASE e.level 
        WHEN "S" THEN 4 
        WHEN "A" THEN 3 
        WHEN "B" THEN 2 
        WHEN "C" THEN 1 
        ELSE 0 
    END) as support_weight

-- 反驳证据权重
reduce(c_weight = 0, e IN contradict_evidence | c_weight + 
    CASE e.level 
        WHEN "S" THEN 4 
        WHEN "A" THEN 3 
        WHEN "B" THEN 2 
        WHEN "C" THEN 1 
        ELSE 0 
    END) as contradict_weight
```

### 4.4 结论判定逻辑（Python层）

```python
# 计算验证结论
if support_weight == 0 and contradict_weight == 0:
    conclusion = "证据不足"
elif support_weight > contradict_weight * 1.5 and contradict_weight > 0:
    conclusion = "证据支持"
elif contradict_weight > support_weight * 1.5 and support_weight > 0:
    conclusion = "证据反驳"
elif support_weight > 0 and contradict_weight > 0:
    conclusion = "证据存在分歧"
elif support_weight > 0:
    conclusion = "证据支持(单方面)"
else:
    conclusion = "证据反驳(单方面)"
```

**判定规则详解**：

| 条件 | 结论 | 说明 |
|------|------|------|
| support > contradict × 1.5 | 证据支持 | 支持权重显著领先（1.5倍） |
| contradict > support × 1.5 | 证据反驳 | 反驳权重显著领先 |
| 双方 > 0 且差距 < 1.5倍 | 证据存在分歧 | 双方势均力敌 |
| 仅support > 0 | 证据支持(单方面) | 无反驳证据 |
| 仅contradict > 0 | 证据反驳(单方面) | 无支持证据 |
| 都为0 | 证据不足 | 无相关证据 |

### 4.5 执行流程图

```
输入: claim_entity="货币政策将利好股市"
         │
         ▼
    ┌─────────────────────────────────────┐
    │ 1. 查找支持证据                      │
    │   MATCH (claim)-[r]->(s)            │
    │   WHERE r.relation_type = "support" │
    └─────────────────────────────────────┘
         │
         ▼
    ┌─────────────────────────────────────┐
    │ 2. 查找反驳证据                      │
    │   MATCH (claim)-[r]->(c)            │
    │   WHERE r.relation_type = "contradict"│
    └─────────────────────────────────────┘
         │
         ▼
    ┌─────────────────────────────────────┐
    │ 3. 计算加权得分                      │
    │   support_weight = Σ(证据权重)       │
    │   contradict_weight = Σ(证据权重)    │
    └─────────────────────────────────────┘
         │
         ▼
    ┌─────────────────────────────────────┐
    │ 4. 判定结论                          │
    │   应用1.5倍阈值规则                  │
    └─────────────────────────────────────┘
         │
         ▼
    输出: {
        "claim": "货币政策将利好股市",
        "conclusion": "证据支持",
        "support_evidence": [...],
        "contradict_evidence": [...],
        "support_weight": 7,
        "contradict_weight": 2
    }
```

---

## 五、核心算法对比总结

| 维度 | 因果链追溯 | 证据聚合 | 交叉验证 |
|------|-----------|---------|---------|
| **图遍历模式** | 变长路径 DFS | 实体+关联查询 | 双分支查询 |
| **边过滤条件** | `relation_type="causal"` | 动态组合 | `support`/`contradict` |
| **权重计算** | reduce累加路径所有边 | sum聚合同实体 | reduce累加双方证据 |
| **排序方式** | 长度→权重 | 总权重降序 | N/A（直接判定） |
| **输出结构** | 路径列表 | 聚合实体列表 | 验证结果对象 |

---

## 六、技术实现亮点

1. **Cypher变长路径语法**：`[r:DIRECTED*1..max_depth]` 高效实现多跳查询

2. **动态条件拼接**：Python层构建Cypher条件，支持可选参数灵活组合

3. **reduce聚合函数**：在数据库层面完成权重计算，减少Python层处理

4. **1.5倍阈值设计**：避免简单多数票决导致的误判，提高结论可靠性

---

## 七、证据等级权重表

| 等级 | 权重 | 含义 |
|------|------|------|
| S | 4 | 最高优先级证据 |
| A | 3 | 高优先级证据 |
| B | 2 | 中等优先级证据 |
| C | 1 | 低优先级证据 |
| 其他 | 0 | 无效/未知证据 |

---

## 八、关系类型说明

| 关系类型 | 作用 | 应用场景 |
|----------|------|----------|
| `causal` | 因果关系 | 因果链追溯 |
| `support` | 支持关系 | 交叉验证 |
| `contradict` | 反驳关系 | 交叉验证 |
| `related` | 关联关系 | 通用关联查询 |

---

*文档版本: v1.0*  
*更新时间: 2026-02-27*  
*来源: kg/neo4j_impl.py 源码分析*
